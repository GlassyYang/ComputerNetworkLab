#! /usr/bin/env python
# -*- coding:utf-8 -*-

"""这个文件是一个库，用来实现网页文件的cache，cache是指将服务端的网页缓存在本地，当浏览器试图访问该网页时，
如果网页没有过期，代理服务器则直接返回该网页。具体的实现方法为：
当从浏览器接收文件时，代理服务器缓存该文件，缓存方法为：将文件的url地址使用MD5散列作为缓存文件的文件名，保存在
cache文件夹中；
当浏览器请求一个文件时，代理服务器通过MD5计算文件URL的MD5散列值，然后试图以只读的方式打开该文件；如果打开不了该文件，
则说明该网页没有缓存；否则获取该文件的最后一次修改的日期，然后向浏览器发送if-modified-since头部，如果浏览器返回304，
说明该文件之后没有被修改，代理服务器则直接返回缓存的数据；如果返回200，则代理服务器向浏览器返回服务器返回的数据并更新
该文件的缓存。"""
from os.path import exists
from os import makedirs
from hashlib import md5
import time


class CacheManager(object):
    def __init__(self):
        # 定义缓存文件存储的路径
        self.__route = './cache/'
        self.__buf_size = 40
        self.__separator = b"\r\n.\r\n"
        self.__sep_len = 5
        if not exists(self.__route):
            makedirs(self.__route)
        return

    @staticmethod
    def ana_filename(data):
        """
        通过浏览器发送的request请求得到文件名，当成功得到文件名之后，函数返回文件名，否则返回None。
        :param data: 浏览器发送的request
        :return: 一个字符串表示文件名，如果无法分析则返回None
        """
        index = data.find(b'Host: ')
        if index == -1:
            return None
        host = []
        index += 6
        while index < len(data) and data[index] != ord(b'\r'):
            host.append(chr(data[index]))
            index += 1
        if index == len(data):
            return None
        url = []
        index = -1
        for i in range(len(data)):
            if data[i] == ord(b' '):
                index = i + 1
                break
        if index == -1:
            return None
        while index < len(data) and data[index] != ord(b' '):
            url.append(chr(data[index]))
            index += 1
        if index == len(data):
            return None
        url = ''.join(url).encode('ascii')
        host = ''.join(host).encode('ascii')
        index = url.find(b'http://')
        if index != -1:
            url = url[7:]
        if url.find(host) == -1:
            url += host
        md = md5()
        md.update(url)
        return md.hexdigest()

    def cached(self, filename):
        """
        check whether specified filename is cached. if not, return false, else return true
        :param filename: which will be checked, should be generated by method ana_filename()
        :return: True if exists, or False
        """
        if exists(self.__route + filename):
            return True
        else:
            return False

    def get_data(self, filename, response):
        """
        Get data from specified filename. filename must exist and generated by method ana_filename()
        :param filename: an existed filename generated by ana_filename()
        :param response: entire 304 response data from server
        :return: data from filename
        """
        f = open(self.__route + filename, 'rb')
        data = f.read()
        index = data.find(self.__separator)
        assert index != -1
        f.close()
        data = data[index + self.__sep_len:]
        # 寻找并更新响应头中的Date头部的值为当前的时间
        index = data.find(b'Date: ')
        index_e = data.find(b'GMT\r\n')
        index += 6
        index_e += 3
        re_index = response.find(b'Date: ')
        re_index_e = response.find(b'GMT\r\n')
        re_index += 6
        re_index_e += 3
        data = data[:index] + response[re_index:re_index_e] + data[index_e:]
        return data

    def cache(self, data, filename):
        """
        缓存文件
        :param data: 服务器返回的完整响应数据
        :param filename: 缓存文件的文件名
        :return: 无返回值
        """
        # 寻找Last-Modified头，将其值保存在文件的开始，用于下一次构造If-Modified_Since头时使用
        index = data.find(b'Last-Modified: ')
        if index == -1:
            return
            # index = data.find(b'Date: ')
            # if index == -1:
            #     return
            # index += 6
        else:
            index += 15
        print('Header "Last-modified" found')
        index_e = index
        while data[index_e] != ord('\r'):
            index_e += 1
        with open(self.__route + filename, 'wb') as f:
            f.write(data[index:index_e])
            f.write(self.__separator)
            f.write(data)

    def timestamp(self, filename):
        """
        获取已缓存网页数据的Last-Modified时间戳
        :param filename: 已缓存网页数据的缓存文件
        :return: 返回GMT格式的Last-Modified时间戳
        """
        assert exists(self.__route + filename)
        f = open(self.__route + filename, 'rb')
        data = f.read(self.__buf_size)
        index = data.find(b'\r\n')
        assert index != 0
        return data[:index]

    @staticmethod
    def time_format():
        """
        获取HTTP规定的时间格式的字符串。
        :return: bytes，内容为当前时间的GMT格式表示
        """
        return time.strftime(time.localtime('%a, %d %b %Y %H:%M:%S GMT', time.time())).encode('ascii')
